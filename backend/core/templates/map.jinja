{% extends "base.jinja" %}

{% block heading %}
GPS Map
{% endblock %}

{% block content %}

<!-- Leaflet.js CSS & JS -->
<link rel="stylesheet" href="/static/css/leaflet.css" />
<link rel="stylesheet" href="/static/css/leaflet.fullscreen.css" />
<script src="/static/js/leaflet.js"></script>
<script src="/static/js/leaflet.fullscreen.js"></script>
<script src="/static/js/leaflet-heat.js"></script>

<style>
    #map {
        height: 600px;
        width: 100%;
        position: relative;
    }

    .loading-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border: 5px solid rgba(255, 255, 255, 0.3);
        border-top: 5px solid #3498db;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        display: none;
        z-index: 1000;
    }

    @keyframes spin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .date-selector {
        margin-bottom: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        justify-content: center;
    }
    .date-selector button, .date-selector input {
        flex: 1 1 auto;
        min-width: 100px;
    }

    /* Simple "legend" or control area in the top-right corner */
    .map-legend {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 999;
        color: #333;
        background: rgba(255, 255, 255, 0.8);
        padding: 8px 12px;
        border-radius: 4px;
    }
</style>

<div class="container mt-4">
    <div class="date-selector">
        <button onclick="adjustDate(-1)">&lt;&lt;</button>
        <div>
            <input type="date" id="start-date"> to 
            <input type="date" id="end-date">
        </div>
        <button onclick="adjustDate(1)">&gt;&gt;</button>
        <button onclick="setDateRange('today')">Today</button>
        <button onclick="setDateRange('yesterday')">Yesterday</button>
        <button onclick="setDateRange('last_week')">Last Week</button>
        <button onclick="setDateRange('last_month')">Last Month</button>
        <button onclick="setDateRange('all')">All</button>
    </div>
    
    <div id="map">
        <div id="loading-spinner" class="loading-spinner"></div>

        <!-- Legend -->
        <div class="map-legend">
            <label>
                <input 
                    type="checkbox" 
                    id="toggleHeatmap" 
                    onchange="toggleHeatmap(this)" 
                />
                Enable Heatmap
            </label>
            <br>
            <!-- enable accuracy filter -->
            <label>
                <input 
                    type="checkbox" 
                    id="toggleAccuracy" 
                    onchange="toggleAccuracy(this)" 
                />
                Enable Accuracy (< 20m)
        </div>
    </div>
</div>

<script>
    var map;
    var polylineLayer;
    var markerLayer;
    var radiusLayer;
    var lastBounds = null;
    var fetchTimeout = null;
    const delay = 500;
    const max_points_for_markers = 300;
    const max_points_for_colored_path = 1000;

    // Heatmap-related variables
    var heatLayer = null;
    var heatmapLoaded = false;  // to ensure data is only loaded once
    var heatmapData = [];       // will be filled upon fetch

    var accuracyFilter = false;

    function initMap() {
        // 1) Check if lat/lng/zoom were provided in the URL
        const params = new URLSearchParams(window.location.search);
        let lat = parseFloat(params.get('lat'));
        let lng = parseFloat(params.get('lng'));
        let zoom = parseInt(params.get('zoom'), 10);

        // Fallback to last_point if missing or invalid
        if (isNaN(lat) || isNaN(lng) || isNaN(zoom)) {
            lat = {{ last_point.latitude }};
            lng = {{ last_point.longitude }};
            zoom = 10;
        }

        map = L.map('map').setView([lat, lng], zoom);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 19,
        }).addTo(map);

        L.control.fullscreen().addTo(map);

        polylineLayer = L.layerGroup().addTo(map);
        markerLayer = L.layerGroup().addTo(map);
        radiusLayer = L.layerGroup().addTo(map);

        // 2) Whenever the map finishes moving or zooming, update the URL
        map.on('moveend', () => {
            updateMapPositionInURL();
            clearTimeout(fetchTimeout);
            fetchTimeout = setTimeout(fetchGPSData, delay);
        });
        map.on('zoomend', () => {
            updateMapPositionInURL();
            clearTimeout(fetchTimeout);
            fetchTimeout = setTimeout(fetchGPSData, delay);
        });

        // Also clear the fetchTimeout on movestart to avoid spamming requests
        map.on('movestart', () => {
            clearTimeout(fetchTimeout);
        });

        // Load the date range from URL if present
        loadDateFromURL();
    }

    function updateMapPositionInURL() {
        const center = map.getCenter();
        const zoom = map.getZoom();

        const params = new URLSearchParams(window.location.search);
        params.set('lat', center.lat.toFixed(6));
        params.set('lng', center.lng.toFixed(6));
        params.set('zoom', zoom);

        // Keep existing start_date and end_date, etc. in place.
        // (They won't be overwritten if not explicitly set here.)
        window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
    }

    function updateURLParams(startDate, endDate) {
        const params = new URLSearchParams(window.location.search);
        params.set('start_date', startDate);
        params.set('end_date', endDate);
        window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
    }

    function fetchGPSData(forced = false) {
        var bounds = map.getBounds();
        if (!bounds) return;

        var zoomLevel = map.getZoom();
        var northEast = bounds.getNorthEast();
        var southWest = bounds.getSouthWest();

        // Skip fetching if the map bounds haven't changed (and not forced)
        if (!forced && lastBounds && lastBounds.equals(bounds)) return;
        lastBounds = bounds;

        document.getElementById("loading-spinner").style.display = "block";

        let startDate = document.getElementById("start-date").value;
        let endDate = document.getElementById("end-date").value;

        fetch("", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                ne_lat: northEast.lat,
                ne_lng: northEast.lng,
                sw_lat: southWest.lat,
                sw_lng: southWest.lng,
                zoom: zoomLevel,
                start_date: startDate,
                end_date: endDate
            })
        })
        .then(response => response.json())
        .then(data => updateMap(data))
        .catch(error => console.error("Error fetching GPS data:", error))
        .finally(() => document.getElementById("loading-spinner").style.display = "none");
    }

    function updateMap(gpsData) {
        polylineLayer.clearLayers();
        markerLayer.clearLayers();
        radiusLayer.clearLayers();

        if (gpsData.length === 0) return;

        var coordinates = gpsData.map(record => ({
            id: record.id,
            lat: record.lat,
            lng: record.lon,
            accuracy: record.ha,
            speed: record.s,
            altitude: record.a,
            timestamp: record.t
        }));

        if (accuracyFilter) {
            coordinates = coordinates.filter(coord => coord.accuracy < 20);
        }

        
        // let startDate = document.getElementById("start-date").value;
        // let endDate = document.getElementById("end-date").value;

        if (coordinates[coordinates.length - 1].timestamp.split("T")[0] === coordinates[0].timestamp.split("T")[0] && coordinates.length < max_points_for_colored_path) {
            for (let i = 0; i < coordinates.length - 1; i++) {
                let color = getSpeedColor(coordinates[i].speed || 0);
                L.polyline([coordinates[i], coordinates[i + 1]], 
                    { 
                        color: color,
                        weight: 2
                    }).addTo(polylineLayer);
            }
        } else {
            var polyline = L.polyline(coordinates.map(coord => [coord.lat, coord.lng]), { 
                color: "#369eff",
                fillColor: "#0b84ff",
                weight: 3
            }).addTo(polylineLayer);
        }


        const center = map.getCenter();
        const centerLat = center.lat;
        const centerLng = center.lng;

        const mapBounds = map.getBounds();

        var newCoords = coordinates.sort((a, b) => {
            // if outside of bounds ignore set distance really high
            if (!mapBounds.contains([a.lat, a.lng])) {
                return 1;
            }
            const distA = (a.lat - centerLat) ** 2 + (a.lng - centerLng) ** 2;
            const distB = (b.lat - centerLat) ** 2 + (b.lng - centerLng) ** 2;
            return distA - distB;
        });

        // cut newCoords to max_points_for_markers
        newCoords = newCoords.slice(0, max_points_for_markers);

        // Add markers if zoomed in enough OR small data set
        if (map.getZoom() > 15 || newCoords.length <= 50) {

            newCoords.forEach(coord => {
                if (coord.accuracy < 5) {
                    return;
                }

                let accuracyMarker = L.circle([coord.lat, coord.lng], {
                    radius: coord.accuracy,
                    color: "blue",
                    weight: 0,
                    opacity: 0,
                    fillOpacity: 0.07
                }).addTo(radiusLayer);
            });

            newCoords.forEach(coord => {
                let marker = L.circleMarker([coord.lat, coord.lng], {
                    radius: 5,
                    fillColor: "#0b84ff",
                    color: "#c7c7cb",
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 1
                }).addTo(markerLayer);

                marker.bindPopup(`
                    <b>Timestamp:</b> ${coord.timestamp} <br>
                    <b>Speed:</b> ${coord.speed ? (coord.speed * 3.6).toFixed(2) + " km/h" : "N/A"} <br>
                    <b>Altitude:</b> ${coord.altitude ? coord.altitude.toFixed(2) + " m" : "N/A"} <br>
                    <b>Accuracy:</b> ${coord.accuracy.toFixed(2)} m <br>
                    <button onclick="deletePoint(${coord.id}, this)">Delete</button>
                    <button onclick="setDateToPoint('${coord.timestamp}')">Set Date</button>
                `);
            });
        }
    }

    function adjustDate(days) {
        let startDateInput = document.getElementById("start-date");
        let endDateInput = document.getElementById("end-date");
        
        let startDate = new Date(startDateInput.value);
        let endDate = new Date(endDateInput.value);
        
        startDate.setDate(startDate.getDate() + days);
        endDate.setDate(endDate.getDate() + days);
        
        startDateInput.value = startDate.toISOString().split('T')[0];
        endDateInput.value = endDate.toISOString().split('T')[0];
        
        updateURLParams(startDateInput.value, endDateInput.value);
        fetchGPSData(true);
    }

    function setDateToPoint(timestamp) {
        let date = new Date(timestamp);
        let formattedDate = date.toISOString().split('T')[0];

        document.getElementById("start-date").value = formattedDate;
        document.getElementById("end-date").value = formattedDate;

        updateURLParams(formattedDate, formattedDate);
        fetchGPSData(true);
    }

    {# function getSpeedColor(speed) {
        let kph = speed * 3.6;
        // Example: color scale from green (low speed) to red (high speed)
        let hue = Math.max(0, Math.min(120 - (kph / 200) * 120, 120));
        return `hsl(${hue}, 100%, 50%)`;
    } #}

    function hexToRGB(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    }

    const colorStops = [
        { speed: 0, color: '#00ff00' },    // Stationary/very slow (green)
        { speed: 15, color: '#00ffff' },   // Walking/jogging (cyan)
        { speed: 30, color: '#ff00ff' },   // Cycling/slow driving (magenta)
        { speed: 50, color: '#ffff00' },   // Urban driving (yellow)
        { speed: 100, color: '#ff3300' }   // Highway driving (red)
    ].map(stop => ({
        ...stop,
        rgb: hexToRGB(stop.color)
    }));

    function getSpeedColor(speed) {

        let speedKmh = speed * 3.6;

        // Find the appropriate color segment
        for (let i = 1; i < colorStops.length; i++) {
            if (speedKmh <= colorStops[i].speed) {
            const ratio = (speedKmh - colorStops[i-1].speed) / (colorStops[i].speed - colorStops[i-1].speed);
            const color1 = colorStops[i-1].rgb;
            const color2 = colorStops[i].rgb;

            const r = Math.round(color1.r + (color2.r - color1.r) * ratio);
            const g = Math.round(color1.g + (color2.g - color1.g) * ratio);
            const b = Math.round(color1.b + (color2.b - color1.b) * ratio);

            return `rgb(${r}, ${g}, ${b})`;
            }
        }

        return colorStops[colorStops.length - 1].color;
    }

    function deletePoint(pointId, button) {
        fetch(`/map?id=${pointId}`, { method: 'DELETE' })
            .then(response => {
                if (response.ok) {
                    map.closePopup();
                    fetchGPSData(true);
                } else {
                    alert("Failed to delete point");
                }
            })
            .catch(error => console.error("Error deleting point:", error));
    }

    function setDateRange(range) {
        let today = new Date();
        let startDate, endDate;

        if (range === 'today') {
            startDate = endDate = today;
        } else if (range === 'yesterday') {
            today.setDate(today.getDate() - 1);
            startDate = endDate = today;
        } else if (range === 'last_week') {
            startDate = new Date(today);
            startDate.setDate(today.getDate() - 7);
            endDate = today;
        } else if (range === 'last_month') {
            startDate = new Date(today);
            startDate.setMonth(today.getMonth() - 1);
            endDate = today;
        } else if (range === 'all') {
            startDate = new Date(0);
            endDate = today;
        }

        startDate = startDate.toISOString().split('T')[0];
        endDate = endDate.toISOString().split('T')[0];

        document.getElementById("start-date").value = startDate;
        document.getElementById("end-date").value = endDate;

        updateURLParams(startDate, endDate);
        fetchGPSData(true);
    }

    function loadDateFromURL() {
        const params = new URLSearchParams(window.location.search);
        const startDate = params.get('start_date');
        const endDate = params.get('end_date');

        if (startDate && endDate) {
            document.getElementById("start-date").value = startDate;
            document.getElementById("end-date").value = endDate;
            fetchGPSData(true);
        } else {
            setDateRange('today');
        }
    }

    // ------------- HEATMAP TOGGLING -------------
    function toggleHeatmap(checkbox) {
        if (checkbox.checked) {
            // If the heatmap data has not been fetched yet, fetch it
            if (!heatmapLoaded) {
                fetchHeatmapData()
                    .then(() => {
                        // Create the heatLayer once data is available
                        heatLayer = L.heatLayer(heatmapData).addTo(map);
                        heatmapLoaded = true;
                    })
                    .catch(err => console.error("Error fetching heatmap data:", err));
            } else {
                // If already loaded before, just add it to the map
                if (heatLayer) {
                    map.addLayer(heatLayer);
                }
            }
        } else {
            // Uncheck: remove the heat layer if it exists
            if (heatLayer) {
                map.removeLayer(heatLayer);
            }
        }
    }

    function toggleAccuracy(checkbox) {
        accuracyFilter = checkbox.checked;
        fetchGPSData(true);
    }

    // Fetch the heatmap data (only once)
    function fetchHeatmapData() {
        document.getElementById("loading-spinner").style.display = "block";
        return fetch("/map/heatmap_data.json")
            .then(response => response.json())
            .then(data => {
                heatmapData = data; // store globally
            })
            .finally(() => document.getElementById("loading-spinner").style.display = "none");
    }

    document.addEventListener("DOMContentLoaded", initMap);
</script>

{% endblock %}
