{% extends "base.jinja" %}

{% block heading %}
GPS Map
{% endblock %}

{% block head %}
<!-- Leaflet.js CSS & JS -->
<link rel="stylesheet" href="/static/css/leaflet.css" />
<link rel="stylesheet" href="/static/css/leaflet.fullscreen.css" />
<link rel="stylesheet" href="/static/css/leaflet.draw.css" />
<script src="/static/js/leaflet.js"></script>
<script src="/static/js/leaflet.fullscreen.js"></script>
<script src="/static/js/leaflet-heat.js"></script>
<script src="/static/js/leaflet.draw.js"></script>

<style>
    #map {
        height: 600px;
        width: 100%;
        position: relative;
    }

    .loading-spinner-text {
        position: absolute;
        top: 45%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: none;
        color: #2c2c2c;
        z-index: 1000;
    }

    .loading-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border: 5px solid rgba(255, 255, 255, 0.3);
        border-top: 5px solid #3498db;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        display: none;
        z-index: 1000;
    }

    @keyframes spin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .date-selector {
        margin-bottom: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        justify-content: center;
    }
    .date-selector button, .date-selector input {
        flex: 1 1 auto;
        min-width: 100px;
    }

    .arrow-button {
        flex: 0 0 auto !important;
        width: auto !important;
        min-width: auto !important;
    }

    .map-legend {
        color: #333;
        background: rgba(255, 255, 255, 0.8);
        padding: 8px 12px;
    }
    
    .calendar-popup-button {
        background: rgba(255, 255, 255, 0.8);
        margin-top: 5px;
        width: 100%;
    }

    .calendar-popup {
        position: absolute;
        top: 160px;   /* leave room below the "📅" button */
        right: 0;
        background: #fff;
        border: 1px solid #ccc;
        padding: 8px;
        z-index: 1000;
        width: 120%;
    }
    .calendar-popup button {
        margin: 4px;
    }
    .calendar-popup select {
        margin-right: 4px;
    }
    .calendar-popup.hidden {
        display: none !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <!-- Date range controls -->
    <div class="date-selector">
        <button onclick="setDateRange('all')">All</button>
        <button onclick="setDateRange('last_month')">Last Month</button>
        <button onclick="setDateRange('last_week')">Last Week</button>
        <button onclick="setDateRange('yesterday')">Yesterday</button>
        <button onclick="setDateRange('today')">Today</button>
        <button class="arrow-button" title="Move back one day" onclick="adjustDate(-1)">&lt;&lt;</button>
        <div>
            <input type="date" id="start-date"> to
            <input type="date" id="end-date">
        </div>
        <button class="arrow-button" title="Move forward one day" onclick="adjustDate(1)">&gt;&gt;</button>
        <button onclick="manualSearch()">Search</button>
    </div>
    
    <!-- Accuracy-based delete controls, hidden by default unless Edit Mode is active -->
    <div id="edit-actions" style="margin-bottom: 10px; text-align: center; display: none;">
        <label>Delete if Accuracy &gt;
            <input type="number" id="accuracyThreshold" style="width: 60px;" value="20" />
        </label>
        <button onclick="filterAndDeleteByAccuracy()">Delete in Selection</button>
    </div>

    <div id="map">
        <div id="loading-spinner" class="loading-spinner"></div>
        <div id="download-percentage" class="loading-spinner-text"></div>
    </div>
</div>

<script>
    // -----------------------
    // Global Variables
    // -----------------------
    var map;
    var polylineLayer;
    var markerLayer;
    var radiusLayer;
    var heatLayer = null;
    var heatmapData = [];
    var heatmapLoaded = false;       // track if heatmap data is already fetched
    var heatmapActive = false;

    var lastGpsData = [];
    var last_point = {{ last_point }};
    var currentDataIsInterpolated = false;
    var lastBounds = null;
    var fetchTimeout = null;
    var preventFetch = false;
    var activateFitBounds = false;

    const delay = 500;
    const max_points_for_markers = 300;
    const max_points_for_colored_path = 1000;

    // Toggles
    var fetchInterpolated = true;
    var accuracyFilter = true;
    var connectFarPoints = true;
    var farThreshold = 1000; // meters
    var showSpeedPolyline = true;
    var editMode = false; // for rectangle selection

    // For rectangle selection / edit mode
    var drawnItems;       // A featureGroup to hold the drawn rectangle
    var drawControl;      // The Leaflet draw control
    var selectedBounds = null; // We'll store the bounding box here

    // ---------------
    // Map Init
    // ---------------
    function initMap() {
        // 1) Check if lat/lng/zoom were provided in the URL
        const params = new URLSearchParams(window.location.search);
        let lat  = parseFloat(params.get('lat'));
        let lng  = parseFloat(params.get('lng'));
        let zoom = parseInt(params.get('zoom'));

        // Fallback to last_point if missing or invalid
        if (isNaN(lat) || isNaN(lng) || isNaN(zoom)) {
            lat = last_point.lat;
            lng = last_point.lng;
            zoom = 14;
        }

        // Create the map
        map = L.map('map').setView([lat, lng], zoom);

        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors',
            maxZoom: 19,
        }).addTo(map);

        // Fullscreen control
        L.control.fullscreen().addTo(map);

        // Prepare layer groups
        polylineLayer = L.layerGroup().addTo(map);
        markerLayer   = L.layerGroup().addTo(map);
        radiusLayer   = L.layerGroup().addTo(map);

        // 2) Create a layer group to store drawn shapes
        drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // 3) Create the draw control (only rectangle)
        drawControl = new L.Control.Draw({
            draw: {
                marker: false,
                polygon: false,
                polyline: false,
                circle: false,
                circlemarker: false,
                rectangle: true
            },
            edit: {
                featureGroup: drawnItems
            }
        });
        // We'll add/remove this control dynamically when Edit Mode is toggled.

        // 4) On rectangle created, keep it and store its bounds
        map.on('draw:created', function (e) {
            var layer = e.layer;
            drawnItems.clearLayers(); // remove old rectangle, if any
            drawnItems.addLayer(layer);

            // Save the bounding box
            selectedBounds = layer.getBounds();
            console.log("Rectangle bounds: ", selectedBounds);
        });

        // Map move/zoom => fetch data
        map.on('moveend', () => {
            if (preventFetch) {
                preventFetch = false;
                return;
            }
            updateMapPositionInURL();
            clearTimeout(fetchTimeout);
            if (fetchInterpolated) {
                fetchTimeout = setTimeout(fetchGPSData, delay);
            }
        });
        map.on('zoomend', () => {
            if (preventFetch) {
                return;
            }
            updateMapPositionInURL();
            clearTimeout(fetchTimeout);
            if (fetchInterpolated) {
                fetchTimeout = setTimeout(fetchGPSData, delay);
            }
        });
        map.on('movestart', () => {
            clearTimeout(fetchTimeout);
        });

        // Load date range from URL or set a default
        loadDateFromURL();

        // Create the custom year/month calendar control
        createCalendarControl();
    }

    // Keep the map center/zoom in the URL
    function updateMapPositionInURL() {
        const center = map.getCenter();
        const zoom   = map.getZoom();

        const params = new URLSearchParams(window.location.search);
        params.set('lat', center.lat.toFixed(6));
        params.set('lng', center.lng.toFixed(6));
        params.set('zoom', zoom);

        window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
    }

    function updateURLParams(startDate, endDate) {
        const params = new URLSearchParams(window.location.search);
        params.set('start_date', startDate);
        params.set('end_date', endDate);
        window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
    }

    // -----------------------
    // Fetch & Progress
    // -----------------------
    function fetchGPSData(forced = false, full_date_range = false, forced_redraw = false) {
        var bounds = map.getBounds();
        if (!bounds) return;

        var zoomLevel = map.getZoom();
        var northEast = bounds.getNorthEast();
        var southWest = bounds.getSouthWest();

        // If the map hasn't changed significantly, skip re-fetch
        if (!forced && lastBounds && (
              lastBounds.equals(bounds) ||
              (!currentDataIsInterpolated && lastBounds.contains(northEast) && lastBounds.contains(southWest))
           )) {
            if (lastGpsData.length > 0) {
                updateMap(lastGpsData, !forced_redraw);
            }
            return;
        }

        lastBounds = bounds;

        document.getElementById("loading-spinner").style.display = "block";
        document.getElementById("download-percentage").style.display = "block";
        document.getElementById("download-percentage").innerText = "0%";

        let startDate = document.getElementById("start-date").value;
        let endDate   = document.getElementById("end-date").value;

        var body = {
            start_date: startDate,
            end_date: endDate,
            fetch_interpolated: fetchInterpolated,
        };

        if (!full_date_range) {
            body.ne_lat = northEast.lat;
            body.ne_lng = northEast.lng;
            body.sw_lat = southWest.lat;
            body.sw_lng = southWest.lng;
            body.zoom   = zoomLevel;
        } else {
            activateFitBounds = true;
        }

        fetch("", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
        })
        .then(response => {
            // Is-Interpolated header
            currentDataIsInterpolated = response.headers.get('Is-Interpolated').toLowerCase() === 'true';

            // Track progress from custom header if provided
            const contentLength = response.headers.get('Content-Original-Length');
            if (!contentLength) {
                return response.json();
            }
            const total = parseInt(contentLength, 10);
            let loaded = 0;
            const reader = response.body.getReader();

            return new Response(new ReadableStream({
                start(controller) {
                    function push() {
                        reader.read().then(({ done, value }) => {
                            if (done) {
                                controller.close();
                                return;
                            }
                            loaded += value.byteLength;
                            const percentage = Math.floor((loaded / total) * 100);
                            document.getElementById("download-percentage").innerText = percentage + '%';
                            controller.enqueue(value);
                            push();
                        }).catch(error => {
                            console.error("Error reading data:", error);
                            controller.error(error);
                        });
                    }
                    push();
                }
            })).json();
        })
        .then(data => {
            // If the data truly changed, update
            if (data.length !== lastGpsData.length ||
                data.some((item, index) => item.id !== lastGpsData[index]?.id)) {
                lastGpsData = data;
                updateMap(data);
            }
        })
        .catch(error => console.error("Error fetching GPS data:", error))
        .finally(() => {
            document.getElementById("loading-spinner").style.display = "none";
            document.getElementById("download-percentage").style.display = "none";
            document.getElementById("download-percentage").innerText = "";
        });
    }

    // -----------------------
    // REBUILD the map entirely
    // -----------------------
    function updateMap(gpsData, softReload = false) {
        // If empty data, just clear layers or do nothing special
        if (!gpsData || gpsData.length === 0) {
            polylineLayer.clearLayers();
            markerLayer.clearLayers();
            radiusLayer.clearLayers();
            return;
        }

        // Convert raw data to a simpler "coordinates" array
        var coordinates = gpsData.map(record => ({
            id:        record.id,
            lat:       record.lat,
            lng:       record.lng,
            accuracy:  record.ha,
            speed:     record.s,
            altitude:  record.a,
            timestamp: record.t
        }));

        // Optionally filter out poor-accuracy points
        if (accuracyFilter) {
            coordinates = coordinates.filter(coord => coord.accuracy < 20);
        }

        if (!softReload) {
            // 1) Save current center & zoom
            let oldCenter = map.getCenter();
            let oldZoom   = map.getZoom();

            // 2) Remove the old map instance but keep the spinners
            map.remove();
            document.getElementById("map").innerHTML =
                '<div id="loading-spinner" class="loading-spinner"></div>' +
                '<div id="download-percentage" class="loading-spinner-text"></div>';

            // 3) Recreate the Leaflet map at same position
            map = L.map('map').setView([oldCenter.lat, oldCenter.lng], oldZoom);

            // 4) Re-add tile layer & controls
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors',
                maxZoom: 19,
            }).addTo(map);
            L.control.fullscreen().addTo(map);

            // 5) Recreate layer groups
            polylineLayer = L.layerGroup().addTo(map);
            markerLayer   = L.layerGroup().addTo(map);
            radiusLayer   = L.layerGroup().addTo(map);

            // Recreate the draw layer & re-bind events
            if (!drawnItems) {
                drawnItems = new L.FeatureGroup();
            }
            map.addLayer(drawnItems);

            // If Edit Mode is currently on, add the draw control again
            var editModeCheckbox = document.getElementById("editModeCheckbox");
            if (editModeCheckbox && editModeCheckbox.checked) {
                map.addControl(drawControl);
            }

            // Re-listen for new rectangle draws
            map.on('draw:created', function (e) {
                var layer = e.layer;
                drawnItems.clearLayers();
                drawnItems.addLayer(layer);
                selectedBounds = layer.getBounds();
                console.log("Rectangle bounds: ", selectedBounds);
            });

            // If heatmap is on, re-add it
            if (heatmapActive && heatLayer) {
                map.addLayer(heatLayer);
            }

            // 6) Re-bind map movement events
            map.on('moveend', () => {
                if (preventFetch) {
                    preventFetch = false;
                    return;
                }
                updateMapPositionInURL();
                clearTimeout(fetchTimeout);
                if (fetchInterpolated) {
                    fetchTimeout = setTimeout(fetchGPSData, delay);
                }
            });
            map.on('zoomend', () => {
                if (preventFetch) {
                    return;
                }
                updateMapPositionInURL();
                clearTimeout(fetchTimeout);
                if (fetchInterpolated) {
                    fetchTimeout = setTimeout(fetchGPSData, delay);
                }
            });
            map.on('movestart', () => {
                clearTimeout(fetchTimeout);
            });

            // Rebuild the calendar control
            createCalendarControl();

            // Draw polylines (optionally with speed-based colors)
            if (showSpeedPolyline) {
                for (let i = 0; i < coordinates.length - 1; i++) {
                    if (!connectFarPoints) {
                        const dist = getCoordinateDistance(
                            coordinates[i].lat, coordinates[i].lng,
                            coordinates[i+1].lat, coordinates[i+1].lng
                        );
                        if (dist > farThreshold) continue;
                    }
                    let color = getSpeedColor(coordinates[i].speed || 0);
                    L.polyline([coordinates[i], coordinates[i+1]], {
                        color: color,
                        weight: 4
                    }).addTo(polylineLayer);
                }
            }
            else if (!connectFarPoints) {
                // Only connect "close" points in small segments
                var segment = [];
                for (let i = 0; i < coordinates.length; i++) {
                    if (i === coordinates.length - 1) {
                        // finalize last segment
                        if (segment.length > 1) {
                            L.polyline(segment.map(c => [c.lat, c.lng]), {
                                color: "#369eff",
                                weight: 3
                            }).addTo(polylineLayer);
                        }
                        break;
                    }
                    const dist = getCoordinateDistance(
                        coordinates[i].lat, coordinates[i].lng,
                        coordinates[i+1].lat, coordinates[i+1].lng
                    );
                    if (dist > farThreshold) {
                        if (segment.length > 1) {
                            L.polyline(segment.map(c => [c.lat, c.lng]), {
                                color: "#369eff",
                                weight: 3
                            }).addTo(polylineLayer);
                        }
                        segment = [];
                    } else {
                        segment.push(coordinates[i]);
                    }
                }
            }
            else {
                // Single big polyline for all points
                L.polyline(coordinates.map(c => [c.lat, c.lng]), {
                    color: "#369eff",
                    weight: 3
                }).addTo(polylineLayer);
            }
        }

        // Render markers
        doMarkers(coordinates);

        // Optionally fit bounds to the entire dataset
        if (activateFitBounds) {
            activateFitBounds = false;
            preventFetch = true;
            var b = new L.LatLngBounds(gpsData.map(c => [c.lat, c.lng]));
            map.fitBounds(b);
        }
    }

    function doMarkers(coordinates) {
        // Clear old markers
        markerLayer.clearLayers();
        radiusLayer.clearLayers();

        const center = map.getCenter();
        const mapBounds = map.getBounds();

        // Sort so that points near the center appear first
        var newCoords = coordinates.sort((a, b) => {
            if (!mapBounds.contains([a.lat, a.lng])) return 1;
            const distA = (a.lat - center.lat)**2 + (a.lng - center.lng)**2;
            const distB = (b.lat - center.lat)**2 + (b.lng - center.lng)**2;
            return distA - distB;
        }).slice(0, max_points_for_markers);

        let selected_point = coordinates.find(coord => coord.id === last_point.id);

        // Only show many markers if zoom is high, or if data set is small
        if (map.getZoom() > 15 || newCoords.length <= 50) {
            // Accuracy circle
            newCoords.forEach(coord => {
                if (coord.accuracy < 5) return;
                L.circle([coord.lat, coord.lng], {
                    radius: coord.accuracy,
                    color: "blue",
                    weight: 0,
                    opacity: 0,
                    fillOpacity: 0.07
                }).addTo(radiusLayer);
            });

            // Dot markers
            newCoords.forEach(coord => {
                if (selected_point &&
                    coord.lat === selected_point.lat &&
                    coord.lng === selected_point.lng
                ) {
                    return; // highlight separately
                }
                createMarker(coord, markerLayer);
            });
        }

        // Highlight a “selected” point if one exists
        if (selected_point) {
            createMarker(selected_point, markerLayer, true);
        }
    }

    // -----------------------
    // Helper: distance in meters
    // -----------------------
    function getCoordinateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371e3; // Earth radius in meters
        const phi1 = lat1 * Math.PI / 180;
        const phi2 = lat2 * Math.PI / 180;
        const deltaPhi = (lat2 - lat1) * Math.PI / 180;
        const deltaLambda = (lng2 - lng1) * Math.PI / 180;

        const a = Math.sin(deltaPhi/2)**2 +
                  Math.cos(phi1)*Math.cos(phi2)*
                  Math.sin(deltaLambda/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // -----------------------
    // Helper: speed colors
    // -----------------------
    function hexToRGB(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    }
    const colorStops = [
        { speed: 0,   color: '#00ff00' },
        { speed: 15,  color: '#00ffff' },
        { speed: 30,  color: '#ff00ff' },
        { speed: 50,  color: '#ffff00' },
        { speed: 100, color: '#ff3300' }
    ].map(stop => ({ ...stop, rgb: hexToRGB(stop.color) }));

    function getSpeedColor(speed) {
        let speedKmh = speed * 3.6;
        for (let i = 1; i < colorStops.length; i++) {
            if (speedKmh <= colorStops[i].speed) {
                const ratio = (speedKmh - colorStops[i-1].speed) /
                              (colorStops[i].speed - colorStops[i-1].speed);
                const c1 = colorStops[i-1].rgb;
                const c2 = colorStops[i].rgb;
                const r = Math.round(c1.r + (c2.r - c1.r)*ratio);
                const g = Math.round(c1.g + (c2.g - c1.g)*ratio);
                const b = Math.round(c1.b + (c2.b - c1.b)*ratio);
                return `rgb(${r}, ${g}, ${b})`;
            }
        }
        return colorStops[colorStops.length - 1].color;
    }

    // -----------------------
    // Helper: create markers
    // -----------------------
    function createMarker(coord, layer, highlight = false) {
        let marker = L.circleMarker([coord.lat, coord.lng], {
            radius: 5,
            fillColor: highlight ? "red" : "#369eff",
            color: "#c7c7cb",
            weight: 3,
            opacity: 1,
            fillOpacity: 1
        }).addTo(layer);

        marker.bindPopup(`
            <b>Timestamp:</b> ${coord.timestamp} <br>
            <b>Speed:</b> ${coord.speed ? (coord.speed * 3.6).toFixed(2) + " km/h" : "N/A"} <br>
            <b>Altitude:</b> ${coord.altitude ? coord.altitude.toFixed(2) + " m" : "N/A"} <br>
            <b>Accuracy:</b> ${coord.accuracy ? coord.accuracy.toFixed(2) + " m" : "N/A"} <br>
            <button onclick="deletePoints([${coord.id}], this)">Delete</button>
            <button onclick="setDateToPoint('${coord.timestamp}')">Set Date</button>
            <button onclick="goToSpeedMap('${coord.id}')">View on Speed Map</button>
        `);
    }

    // -----------------------
    // Single Delete using the same /map JSON-based approach
    // -----------------------
    function deletePoints(pointIds, button) {
        fetch("/map", {
            method: "DELETE",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ids: pointIds })
        })
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => { throw new Error(text); });
            }
            return response.text();
        })
        .then(msg => {
            console.log("Delete success:", msg);
            map.closePopup();
            fetchGPSData(true);
        })
        .catch(error => {
            console.error("Error deleting point:", error);
            alert("Failed to delete point: " + error.message);
        });
    }

    function goToSpeedMap(pointId) {
        window.location.href = `/map/speed?point_id=${pointId}`;
    }

    // -----------------------
    // Date Range & Searching
    // -----------------------
    function adjustDate(days) {
        let startDateInput = document.getElementById("start-date");
        let endDateInput   = document.getElementById("end-date");
        
        function parseAsUTC(dateStr) {
            const [y, m, d] = dateStr.split('-').map(Number);
            return new Date(Date.UTC(y, m - 1, d));
        }

        let startDate = parseAsUTC(startDateInput.value);
        let endDate   = parseAsUTC(endDateInput.value);

        startDate.setUTCDate(startDate.getUTCDate() + days);
        endDate.setUTCDate(endDate.getUTCDate() + days);

        let newStart = startDate.toISOString().substring(0, 10);
        let newEnd   = endDate.toISOString().substring(0, 10);

        startDateInput.value = newStart;
        endDateInput.value   = newEnd;

        updateURLParams(newStart, newEnd);
        fetchGPSData(true, true);
    }

    function setDateToPoint(timestamp) {
        let date = new Date(timestamp);
        let formattedDate = date.toISOString().split('T')[0];

        document.getElementById("start-date").value = formattedDate;
        document.getElementById("end-date").value = formattedDate;
        updateURLParams(formattedDate, formattedDate);
        fetchGPSData(true);
    }

    function setDateRange(range, fetch_after = true, full_date_range = true) {
        let today = new Date();
        let startDate, endDate;

        if (range === 'today') {
            startDate = endDate = today;
        } else if (range === 'yesterday') {
            today.setDate(today.getDate() - 1);
            startDate = endDate = today;
        } else if (range === 'last_week') {
            startDate = new Date(today);
            startDate.setDate(today.getDate() - 7);
            endDate = today;
        } else if (range === 'last_month') {
            startDate = new Date(today);
            startDate.setMonth(today.getMonth() - 1);
            endDate = today;
        } else if (range === 'all') {
            startDate = new Date(0);
            endDate = today;
        }

        startDate = startDate.toISOString().split('T')[0];
        endDate   = endDate.toISOString().split('T')[0];

        document.getElementById("start-date").value = startDate;
        document.getElementById("end-date").value   = endDate;

        updateURLParams(startDate, endDate);

        if (fetch_after) {
            fetchGPSData(true, full_date_range);
        }
    }

    function manualSearch() {
        let start = document.getElementById("start-date").value;
        let end   = document.getElementById("end-date").value;
        updateURLParams(start, end);
        fetchGPSData(true, true);
    }

    function loadDateFromURL() {
        const params = new URLSearchParams(window.location.search);
        const startDate = params.get('start_date');
        const endDate   = params.get('end_date');
        const prevent_auto_move = (params.get('view_location') === 'true');

        if (startDate && endDate) {
            document.getElementById("start-date").value = startDate;
            document.getElementById("end-date").value   = endDate;
            fetchGPSData(true, false);
        } else if (prevent_auto_move) {
            params.delete('view_location');
            window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
            setDateRange('all', true, false);
        } else {
            setDateRange('today');
        }
    }

    // -----------------------
    // Heatmap
    // -----------------------
    function toggleHeatmap(checkbox) {
        heatmapActive = checkbox.checked;
        if (checkbox.checked) {
            if (!heatmapLoaded) {
                fetchHeatmapData().then(() => {
                    heatLayer = L.heatLayer(heatmapData).addTo(map);
                    heatmapLoaded = true;
                }).catch(err => console.error("Error fetching heatmap data:", err));
            } else {
                if (heatLayer) map.addLayer(heatLayer);
            }
        } else {
            if (heatLayer) map.removeLayer(heatLayer);
        }
    }

    function fetchHeatmapData() {
        document.getElementById("loading-spinner").style.display = "block";
        document.getElementById("download-percentage").style.display = "block";
        document.getElementById("download-percentage").innerText = "0%";

        return fetch("/map/heatmap_data.csv")
            .then(response => {
                const contentLength = response.headers.get('Content-Original-Length');
                if (!contentLength) {
                    return response.text();
                }
                const total = parseInt(contentLength, 10);
                let loaded  = 0;
                const reader = response.body.getReader();

                return new Response(new ReadableStream({
                    start(controller) {
                        function push() {
                            reader.read().then(({ done, value }) => {
                                if (done) {
                                    controller.close();
                                    return;
                                }
                                loaded += value.byteLength;
                                const percentage = Math.floor((loaded / total) * 100);
                                document.getElementById("download-percentage").innerText = percentage + '%';
                                controller.enqueue(value);
                                push();
                            }).catch(error => {
                                console.error("Error reading data:", error);
                                controller.error(error);
                            });
                        }
                        push();
                    }
                })).text();
            })
            .then(data => {
                heatmapData = data.split('\n').map(line => {
                    const [lat, lng] = line.split(',').map(Number);
                    return [lat / 10000, lng / 10000];
                }).filter(coord => coord.length === 2);

                // If the last line was blank, remove it
                if (heatmapData.length && isNaN(heatmapData[heatmapData.length - 1][0])) {
                    heatmapData.pop();
                }
            })
            .finally(() => {
                document.getElementById("loading-spinner").style.display = "none";
                document.getElementById("download-percentage").style.display = "none";
                document.getElementById("download-percentage").innerText = "";
            });
    }

    // -----------------------
    // Toggling Interpolated, etc.
    // -----------------------
    function toggleFetchInterpolated(checkbox) {
        fetchInterpolated = checkbox.checked;
        let showSpeedPolylineElement = document.getElementById("toggleSpeedPolyline");
        if (showSpeedPolylineElement.checked && !fetchInterpolated) {
            // If "speed colors" is on but interpolation is off, disable speed
            showSpeedPolylineElement.checked = false;
            showSpeedPolyline = false;
        }
        fetchGPSData(true);
    }

    function toggleAccuracy(checkbox) {
        accuracyFilter = checkbox.checked;
        fetchGPSData(false, false, true);
    }

    function toggleConnectFarPoints(checkbox) {
        connectFarPoints = checkbox.checked;
        fetchGPSData(false, false, true);
    }

    function toggleSpeedPolyline(checkbox) {
        showSpeedPolyline = checkbox.checked;
        let fetchInterpolatedElement = document.getElementById("fetchInterpolated");
        if (!fetchInterpolatedElement.checked && showSpeedPolyline) {
            fetchInterpolatedElement.checked = true;
            fetchInterpolated = true;
        }
        fetchGPSData(false, false, true);
    }

    // -----------------------
    // Edit Mode Toggle
    // -----------------------
    function toggleEditMode(checkbox) {
        editMode = checkbox.checked;
        // Show/hide the rectangle-drawing control
        if (checkbox.checked) {
            map.addControl(drawControl);
            // Also show the accuracy-based delete UI
            document.getElementById("edit-actions").style.display = "block";
        } else {
            map.removeControl(drawControl);
            drawnItems.clearLayers();
            selectedBounds = null;
            // Hide the accuracy-based delete UI
            document.getElementById("edit-actions").style.display = "none";
        }
    }

    // -----------------------
    // Filter & Delete by Accuracy (Bulk)
    // -----------------------
    function filterAndDeleteByAccuracy() {
        if (!selectedBounds) {
            alert("No rectangle is drawn yet!");
            return;
        }

        // Gather accuracy threshold from the UI
        const accThr = parseFloat(document.getElementById('accuracyThreshold').value) || 999999;

        // Among lastGpsData, find points within the rectangle and with accuracy above threshold
        const toDelete = lastGpsData.filter(pt => {
            const withinRect = selectedBounds.contains([pt.lat, pt.lng]);
            if (!withinRect) return false;
            return (pt.ha > accThr);
        });

        if (!toDelete.length) {
            alert("No points match the accuracy condition in the selected area.");
            return;
        }

        if (!confirm("Delete " + toDelete.length + " points in this rectangle?")) {
            return;
        }

        // Send { "ids": [...] } to the unified DELETE /map endpoint
        const ids = toDelete.map(pt => pt.id);
        deletePoints(ids);
    }

    // -----------------------
    // Build Custom Calendar Control
    // -----------------------
    function createCalendarControl() {
        var CalendarControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) {
                var container = L.DomUtil.create('div', 'leaflet-control leaflet-bar map-legend');
                var legend = L.DomUtil.create('div', '', container);

                legend.innerHTML = `
                    <label>
                        <input 
                            type="checkbox" 
                            id="fetchInterpolated" 
                            onchange="toggleFetchInterpolated(this)" 
                            ${fetchInterpolated ? 'checked' : ''}
                        />
                        Interpolated Trace
                    </label>
                    <br>
                    <label>
                        <input 
                            type="checkbox" 
                            id="toggleHeatmap" 
                            onchange="toggleHeatmap(this)" 
                            ${heatmapActive ? 'checked' : ''}
                        />
                        Enable Heatmap
                    </label>
                    <br>
                    <label>
                        <input 
                            type="checkbox" 
                            id="toggleAccuracy" 
                            onchange="toggleAccuracy(this)" 
                            ${accuracyFilter ? 'checked' : ''}
                        />
                        Filter Accuracy (&lt; 20m)
                    </label>
                    <br>
                    <label>
                        <input 
                            type="checkbox" 
                            onchange="toggleConnectFarPoints(this)" 
                            ${connectFarPoints ? 'checked' : ''}
                        />
                        Connect Far Points
                    </label>
                    <br>
                    <label>
                        <input 
                            type="checkbox" 
                            id="toggleSpeedPolyline" 
                            onchange="toggleSpeedPolyline(this)" 
                            ${showSpeedPolyline ? 'checked' : ''}
                        />
                        Speed Colors
                    </label>
                    <br>
                    <!-- Renamed to "Edit Mode" -->
                    <label>
                        <input 
                            type="checkbox" 
                            id="editModeCheckbox"
                            onchange="toggleEditMode(this)"
                            ${editMode ? 'checked' : ''}
                        />
                        Edit Mode
                    </label>
                `;

                // Toggle calendar button
                var toggleBtn = L.DomUtil.create('button', 'calendar-popup-button', container);
                toggleBtn.innerHTML = '📅';
                toggleBtn.title = 'Select Year/Month';

                var popup = L.DomUtil.create('div', 'calendar-popup hidden', container);

                // Year select
                var yearSelect = L.DomUtil.create('select', '', popup);
                var currentYear = new Date().getFullYear();
                for (var y = currentYear; y >= {{ earliest_year }}; y--) {
                    var option = L.DomUtil.create('option', '', yearSelect);
                    option.value = y;
                    option.textContent = y;
                }

                // Whole year button
                var wholeYearBtn = L.DomUtil.create('button', '', popup);
                wholeYearBtn.innerHTML = 'Whole year';
                wholeYearBtn.onclick = function() {
                    var y = parseInt(yearSelect.value);
                    var startDate = y + '-01-01';
                    var endDate   = y + '-12-31';
                    document.getElementById('start-date').value = startDate;
                    document.getElementById('end-date').value   = endDate;
                    updateURLParams(startDate, endDate);
                    fetchGPSData(true, true);
                };

                // Month grid
                var monthsContainer = L.DomUtil.create('div', '', popup);
                monthsContainer.style.display = 'grid';
                monthsContainer.style.gridTemplateColumns = 'repeat(3, auto)';
                monthsContainer.style.gap = '4px';

                var monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                for (let m = 1; m <= 12; m++) {
                    let btn = L.DomUtil.create('button', '', monthsContainer);
                    btn.innerHTML = monthNames[m-1];
                    btn.onclick = function() {
                        var y = parseInt(yearSelect.value);
                        var mm = String(m).padStart(2, '0');
                        var startDate = y + '-' + mm + '-01';
                        var lastDay = new Date(y, m, 0).getDate();
                        var endDate  = y + '-' + mm + '-' + lastDay;
                        document.getElementById('start-date').value = startDate;
                        document.getElementById('end-date').value   = endDate;
                        updateURLParams(startDate, endDate);
                        fetchGPSData(true, true);
                    };
                }

                // Toggle popup
                toggleBtn.onclick = function() {
                    popup.classList.toggle('hidden');
                };

                // Prevent clicks on the control from propagating
                L.DomEvent.disableClickPropagation(container);

                return container;
            }
        });

        map.addControl(new CalendarControl());
    }

    // Init everything
    document.addEventListener("DOMContentLoaded", initMap);
</script>
{% endblock %}
